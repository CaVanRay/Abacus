input( numA, numB){

numA -> string -> TopV
numB -> string -> BotV

TopV[#] * BotV[#] = ProdV[#]

} output( numC)

**********************************************************************************************************************************
This is still my focus, BUT i did learn some really useful stuff using ceiling() & floor()

**********************************************************************************************************************************
While in a meeting today I realized I have yet to make a basic multiplication version of this, I've worked on factorials and squaring every number up to 100, but just a basic 2 number input, 1 number output, multiplication I have yet to do.

If I don't do anything else, That is my one goal tomorrow, jesus christ

...wait, if I do anything at all, that is going to be it. No excuses, be careful with your wording.

**********************************************************************************************************************************

Next I need to handle decimals, top two ideas are to either [test for and ignore] and [designate spot and work around]

this is going to be more difficult than I thought...

Options:

Handle inside of Array
[0][0][0][.][0][0][0]

Designate decimal location without literally holding it

       --V-- *Decimal goes here*
[0][0][0]  [0][0][0]

Or split pre-decimal & post-decimal numbers into 2 seperate arrays0

Pre-D:  [0][0][0]
Post-D: [0][0][0]


**********************************************************************************************************************************

This will be the same as factorial, I just need to bring in 2 numbers instead of 1, and remove the outer loop. - Done.

**********************************************************************************************************************************
Copying over my notes from making factorial program.

I think there will be at least 3 vector arrays, possibly 4 depending on how I want to handle "Carry over"

  Carry over          :[ ]
  Top Vector          :[ , ,]
  Bottom Vector       :[ , ,]
  Product Vector      :[ , ,]

  Each vector contains the individual digits of each number seperately so as to calculate much larger numbers
  
  each step multiplies top and bottom to get product, the product moves to top and the bottom goes down by one

For the carry over function it will be something like this:

while(# > 9){
# = # - 10;
carry = carry + 1
}

if(carry > 0) {
  product[#] = product[#] + carryover;    will have to find a way to specify which item in product vector.
  carry = 0
}
Simple outline of how this will work:

Product[0] = Top[0] * Bot[0] 
Product[1] = Carry + (Top[0] * Bot[1])
Product[0] = Product[0] + (Top[1] * Bot[0])
Product[1] = Product[1] + Carry + (Top[1] * Bot[1])

The logic works, I just need to expand it in a way that is self testing/expanding

This works, I just need to put it together.

The larger number will always be on top after each multiplication

Top[] = Product[]

then you measure both the top & bottom

TopSize = Top.size()
BotSize = Bot.size()

and you use these to run through the for loops again
NOTE: Product[] Placemnet matches Top[] at start and increments by one! this avoids adding 0's

Product[0] = Product[0] + Carry + (Top[0] * Bot[0]) 
Product[1] = Product[1] + Carry + (Top[0] * Bot[1])
Product[1] = Product[1] + Carry + (Top[1] * Bot[0])
Product[2] = Product[2] + Carry + (Top[1] * Bot[1])
Product[2] = Product[2] + Carry + (Top[2] * Bot[0])
Product[3] = Product[3] + carry + (Top[2] * Bot[1])

at some point you have to test the sizes of Top[] & Bot[], and possibly Pro[].
and I feel like there may have to be some resizing at some point, but I havent had a chance to work through it from start to finish

Top.size() + Bot.size() + 1 = Pro[]'s size
Even if it's a little bigger than the number I need to hold since: 00100 == 100, adding leading 0's changes nothing and I can remove that in the output stage.

I think I have everything I need to do this, I'm just lacking the willpower at this point.

I might be headed for stormy weather, :-/

Input: single integer
Process: Multiply integer by itself and every integer down to 1 (factorial)
Output: display the factorial of integer input

Highest multiplication should be 9*9
  so max digits handled at once is limited to 2 ( 9*9 = 81)
    while(answer > 9)  {
      answer = answer - 10;
      carry = carry + 1;
    }
Each time the carry over is added to the product it needs to be wiped out
    if(carry > 0)  {
      product[#] = product[#] + carry;
      carry = 0;
    }

OOO: (This is overly simplified and I will try to finish it tomorrow. If I don't, I will do it on saturday)
      1  - int comes in
      2  - set the top, bot, & size
      3  - For loop on Size 
      4  - set prolocation (note: I need to run through the prolocation movement to make sure I have the pattern down)
      5  - For loop on Top (will always be the larger number) 
      6  - For loop on Bot (Each number in Top will run through each number in Bot) 
      7  - Prolocation ++ (The prolocation will update when the Bot number changes)
      8  - Close Bot For
      9  - Close Top For
      10 - Bot -- (25 -> 24 -> 23 ->... you get the picture)
      11 - Size --
      12 - Top = Pro (technically these could just be one item, but for clarity sake im using two)
      13 - Close Size For
      14 - Output final Pro

I just need to work harder tomorrow

fuck
